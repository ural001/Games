<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>tavla</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&display=swap');

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg:   #1a1208;
  --surf: #2a1e10;
  --bord: #3d2e1a;
  --txt:  #f0e8d8;
  --dim:  #7a6a54;
  --red:  #c0392b;
  --gold: #d4a030;
}

html, body {
  height: 100%;
  overflow: hidden;
}
body {
  background: #0e0a06;
  color: var(--txt);
  font-family: 'DM Mono', 'Courier New', monospace;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* ── SCREENS ── */
.scr { display: none; flex-direction: column; align-items: center; }
.scr.on { display: flex; animation: fadeup .4s ease both; }
@keyframes fadeup { from{opacity:0;transform:translateY(10px)} to{opacity:1;transform:none} }

/* ── LOBBY ── */
#lobby { gap: 32px; padding: 24px; width: 100%; max-width: 500px; }

h1 { font-size: clamp(40px,8vw,88px); font-weight:300; letter-spacing:.32em; line-height:1; }
h1 span { color: var(--red); }

.panels { display: flex; gap: 2px; background: var(--bord); width: 100%; }
.panel { background:var(--surf); padding:24px; flex:1; display:flex; flex-direction:column; gap:12px; }
.plabel { font-size:9px; letter-spacing:.2em; text-transform:uppercase; color:var(--dim); border-bottom:1px solid var(--bord); padding-bottom:8px; }

input { background:var(--bg); border:1px solid var(--bord); color:var(--txt); font-family:inherit; font-size:18px; letter-spacing:.14em; padding:10px 12px; text-transform:uppercase; width:100%; outline:none; transition:border-color .12s; }
input:focus { border-color:var(--red); }
input::placeholder { color:var(--dim); font-size:11px; letter-spacing:.05em; }

button { background:none; border:1px solid currentColor; color:var(--txt); font-family:inherit; font-size:9px; letter-spacing:.2em; text-transform:uppercase; padding:10px 16px; cursor:pointer; transition:background .1s,color .1s; touch-action:manipulation; }
button:hover:not(:disabled) { background:var(--txt); color:var(--bg); }
button:active:not(:disabled) { transform:scale(.97); }
button:disabled { opacity:.3; cursor:default; }
button.red { color:var(--red); }
button.red:hover:not(:disabled) { background:var(--red); color:var(--txt); }
button.tiny { font-size:8px; padding:5px 10px; color:var(--dim); }
button.tiny:hover:not(:disabled) { background:var(--dim); color:var(--bg); }

.codebox { background:var(--bg); border:1px solid var(--bord); padding:8px 12px; display:flex; align-items:center; gap:8px; }
.bigcode { font-size:22px; letter-spacing:.2em; font-weight:500; flex:1; }

.msg { font-size:10px; letter-spacing:.06em; color:var(--dim); line-height:1.6; }
.msg.ok  { color:var(--gold); }
.msg.err { color:var(--red); }
@keyframes blink { 50%{opacity:0} }
.blink { animation:blink 1s infinite; }

/* ── GAME — desktop: horizontal layout preserved ── */
#game {
  width: 100%;
  max-width: 1200px;
  padding: 12px 16px;
  gap: 8px;
  /* on mobile we switch to column filling full screen height */
}

.gtop { width:100%; display:flex; align-items:center; justify-content:space-between; flex-shrink:0; }
.gtitle { font-size:10px; letter-spacing:.22em; color:var(--dim); }

/* Scoreboard pill row */
.score-row { width:100%; display:flex; align-items:center; justify-content:space-between; flex-shrink:0; }
.score-box {
  display:flex; align-items:center; gap:8px;
  font-size:9px; letter-spacing:.14em;
  padding:4px 10px;
  border:1px solid var(--bord);
}
.score-box .s-label { color:var(--dim); }
.score-box .s-pips  { display:flex; gap:4px; }
.score-dot { width:8px; height:8px; border-radius:50%; background:var(--bord); }
.score-dot.filled.white { background:#e8dfc8; }
.score-dot.filled.black { background:#555; }
.score-box.active { border-color:var(--gold); }

.pill { font-size:9px; letter-spacing:.14em; padding:4px 12px; border:1px solid var(--bord); transition:all .2s; }
.pill.mine   { border-color:var(--gold); color:var(--gold); }
.pill.theirs { color:var(--dim); }

/* Off bars */
.off-bar { width:100%; display:flex; align-items:center; min-height:20px; padding:2px 4px; gap:4px; flex-shrink:0; }
.off-pips { display:flex; gap:3px; flex-wrap:wrap; align-items:center; }
.off-pip { width:11px; height:11px; border-radius:50%; display:inline-block; flex-shrink:0; }
.off-pip.w { background:#e8dfc8; border:1px solid #b8a888; }
.off-pip.b { background:#2a2a2a; border:1px solid #555; }
.off-count { font-size:10px; color:var(--dim); margin-left:2px; }

/* Canvas */
.cvs-wrap { width:100%; position:relative; flex-shrink:1; }
.cvs-wrap.flipped canvas { transform:rotate(180deg); }
canvas { display:block; width:100%; cursor:pointer; touch-action:none; }
canvas.dragging { cursor:grabbing; }

@keyframes dieroll {
  0%  {transform:scale(1.1) rotate(-8deg);opacity:.6}
  25% {transform:scale(0.9) rotate(6deg); opacity:.8}
  50% {transform:scale(1.15) rotate(-4deg);opacity:.7}
  75% {transform:scale(0.95) rotate(3deg);opacity:.9}
  100%{transform:scale(1) rotate(0);      opacity:1}
}
.die.rolling { animation:dieroll .08s linear infinite; border-color:var(--gold)!important; color:var(--gold)!important; }

/* Reconnect overlay */
#reconnect-overlay { display:none; position:fixed; inset:0; background:rgba(14,10,6,.93); z-index:200; flex-direction:column; align-items:center; justify-content:center; gap:16px; }
#reconnect-overlay.show { display:flex; animation:fadeup .3s ease both; }
.rc-title { font-size:16px; letter-spacing:.15em; }
.rc-dots  { font-size:26px; letter-spacing:.3em; color:var(--gold); animation:blink 1s infinite; }
.rc-sub   { font-size:10px; letter-spacing:.1em; color:var(--dim); }
.rc-buts  { display:flex; gap:8px; margin-top:4px; }

/* Bottom controls */
.gbot { width:100%; display:flex; align-items:center; gap:8px; flex-shrink:0; padding:2px 0; }
.dice { display:flex; gap:6px; }
.die { width:52px; height:52px; border:2px solid var(--bord); border-radius:6px; display:flex; align-items:center; justify-content:center; font-size:26px; font-weight:500; }
.die.live { border-color:var(--gold); color:var(--gold); }
.die.dead { opacity:.18; }
.gbuts { margin-left:auto; display:flex; gap:7px; }

.hint { width:100%; font-size:9px; letter-spacing:.08em; color:var(--dim); text-align:center; height:14px; transition:color .15s; flex-shrink:0; }
.hint.hi  { color:var(--gold); }
.hint.err { color:var(--red); }

/* End screen */
#end { gap:20px; padding:24px; }
.bigword { font-size:clamp(44px,8vw,80px); font-weight:300; letter-spacing:.08em; }
.bigword.win  { color:var(--gold); }
.bigword.lose { color:var(--red); }
.sub { font-size:10px; letter-spacing:.16em; color:var(--dim); margin-top:-12px; }
.endbuts { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }

/* ── MOBILE overrides ── */
@media (max-width: 600px) {
  html, body { overflow: hidden; }

  body { align-items: stretch; justify-content: stretch; }

  #lobby {
    padding: 20px 16px;
    justify-content: center;
    min-height: 100dvh;
  }
  .panels { flex-direction: column; }
  .panel { padding: 16px; }

  #game {
    padding: 8px 10px;
    min-height: 100dvh;
    max-height: 100dvh;
    justify-content: space-between;
  }

  .die { width: 44px; height: 44px; font-size: 22px; }

  .off-pip { width: 9px; height: 9px; }

  /* Roll button bigger on mobile for fat fingers */
  .gbuts button { padding: 14px 20px; font-size: 10px; }
}
</style>
</head>
<body>

<!-- RECONNECT -->
<div id="reconnect-overlay">
  <div class="rc-title">bağlantı kesildi</div>
  <div class="rc-dots">· · ·</div>
  <div class="rc-sub" id="rc-sub-text">rakip yeniden bağlanmayı bekliyor</div>
  <div class="rc-buts">
    <button id="btn-reconnect" class="red" style="display:none">Yeniden Bağlan</button>
    <button id="btn-give-up">Vazgeç</button>
  </div>
</div>

<!-- LOBBY -->
<div id="lobby" class="scr on">
  <h1>tav<span>l</span>a</h1>
  <div class="panels">
    <div class="panel">
      <div class="plabel">Yeni Oyun</div>
      <button class="red" id="btn-create">Oda Oluştur</button>
      <div id="create-more" style="display:none;flex-direction:column;gap:10px">
        <div class="codebox">
          <span class="bigcode" id="mycode">----</span>
          <button class="tiny" id="btn-copy">Kopyala</button>
        </div>
        <div class="msg" id="cmsg">Rakip bekleniyor<span class="blink">…</span></div>
      </div>
    </div>
    <div class="panel">
      <div class="plabel">Odaya Katıl</div>
      <input id="codein" maxlength="5" placeholder="Kodu gir">
      <button id="btn-join">Bağlan</button>
      <div class="msg" id="jmsg"></div>
    </div>
  </div>
  <div class="msg" style="max-width:440px;text-align:center;line-height:1.9">
    Aynı ağdaki iki sekmede açabilirsiniz.<br>
    Farklı ağ için: <code>npx serve .</code> → linki paylaş
  </div>
</div>

<!-- GAME -->
<div id="game" class="scr">
  <div class="gtop">
    <span class="gtitle">tavla</span>
    <span class="pill" id="pill">—</span>
  </div>
  <!-- Scoreboard -->
  <div class="score-row">
    <div class="score-box" id="score-opp">
      <span class="s-label" id="score-opp-label">rakip</span>
      <div class="s-pips" id="score-opp-pips"></div>
    </div>
    <div class="score-box" id="score-me">
      <div class="s-pips" id="score-me-pips"></div>
      <span class="s-label" id="score-me-label">ben</span>
    </div>
  </div>
  <!-- Opponent off -->
  <div class="off-bar">
    <div class="off-pips" id="off-opp-pips"></div>
    <span class="off-count" id="off-opp-cnt"></span>
  </div>
  <!-- Board -->
  <div class="cvs-wrap" id="cvs-wrap">
    <canvas id="cvs"></canvas>
  </div>
  <div class="hint" id="hint">—</div>
  <!-- My off -->
  <div class="off-bar">
    <div class="off-pips" id="off-my-pips"></div>
    <span class="off-count" id="off-my-cnt"></span>
  </div>
  <!-- Controls -->
  <div class="gbot">
    <div class="dice" id="dice"></div>
    <div class="gbuts">
      <button class="red" id="btn-roll" disabled>Zar At</button>
    </div>
  </div>
</div>

<!-- END -->
<div id="end" class="scr">
  <div class="bigword" id="endword">—</div>
  <div class="sub" id="endsub"></div>
  <div id="score-display" style="font-size:13px;letter-spacing:.12em;color:var(--dim)"></div>
  <div class="endbuts">
    <button class="red" id="btn-rematch">Tekrar Oyna</button>
    <button id="btn-home">Ana Sayfa</button>
  </div>
</div>

<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<script>
"use strict";

/* ════════════════════════════════════════
   SCREEN
════════════════════════════════════════ */
function show(id){
  ['lobby','game','end'].forEach(s=>document.getElementById(s).classList.toggle('on',s===id));
  if(id==='game'){resizeCvs();render();}
}

/* ════════════════════════════════════════
   SCORE  (persists across rematches)
════════════════════════════════════════ */
const SCORE = { me:0, opp:0, target:5 };

function updateScoreUI(){
  const isMeWhite = myColor==='white';
  document.getElementById('score-me-label').textContent  = isMeWhite?'beyaz':'siyah';
  document.getElementById('score-opp-label').textContent = isMeWhite?'siyah':'beyaz';
  renderScorePips('score-me-pips',  SCORE.me,  isMeWhite);
  renderScorePips('score-opp-pips', SCORE.opp, !isMeWhite);
}
function renderScorePips(id, count, white){
  const el=document.getElementById(id); el.innerHTML='';
  for(let i=0;i<SCORE.target;i++){
    const d=document.createElement('span');
    d.className='score-dot'+(i<count?' filled '+(white?'white':'black'):'');
    el.appendChild(d);
  }
}

/* ════════════════════════════════════════
   STATE
════════════════════════════════════════ */
let myColor  = null;
let peer     = null;
let conn     = null;
let voted    = false;
let roomCode = null;
let isHost   = false;

const S = {
  board:null, bar:[0,0], off:[0,0],
  dice:[], used:[],
  turn:'white', phase:'roll', winner:null,
  sel:null, valid:[]
};

function freshBoard(){
  const b=new Array(24).fill(0);
  b[23]=2; b[12]=5; b[7]=3; b[5]=5;
  b[0]=-2; b[11]=-5; b[16]=-3; b[18]=-5;
  return b;
}
function resetState(){
  S.board=freshBoard(); S.bar=[0,0]; S.off=[0,0];
  S.dice=[]; S.used=[]; S.turn='white'; S.phase='roll';
  S.winner=null; S.sel=null; S.valid=[];
}

/* ════════════════════════════════════════
   PEER CONFIG
════════════════════════════════════════ */
const PEER_OPTS={
  debug:0,
  config:{iceServers:[
    {urls:'stun:stun.l.google.com:19302'},
    {urls:'stun:stun1.l.google.com:19302'},
    {urls:'stun:stun.stunprotocol.org:3478'},
    {urls:'turn:openrelay.metered.ca:80',    username:'openrelayproject',credential:'openrelayproject'},
    {urls:'turn:openrelay.metered.ca:443',   username:'openrelayproject',credential:'openrelayproject'},
    {urls:'turn:openrelay.metered.ca:443?transport=tcp',username:'openrelayproject',credential:'openrelayproject'},
  ]}
};
const CONN_OPTS={reliable:true,serialization:'json'};
function newPeer(id){return id?new Peer(id,PEER_OPTS):new Peer(PEER_OPTS);}

/* ════════════════════════════════════════
   RECONNECT — robust version
   Host keeps its Peer ID = roomCode so guest can always reconnect.
   Guest stores roomCode and re-connects on drop.
   Both sides show overlay with a manual "Yeniden Bağlan" button
   in case auto-retry fails, plus 90s timeout before giving up.
════════════════════════════════════════ */
const rcOverlay   = document.getElementById('reconnect-overlay');
const rcSubText   = document.getElementById('rc-sub-text');
const rcReconBtn  = document.getElementById('btn-reconnect');
let rcTimeout     = null;
let rcAutoInterval= null;
let rcAttempts    = 0;

function showReconnect(msg){
  rcSubText.textContent = msg || 'yeniden bağlanmayı deniyor…';
  rcOverlay.classList.add('show');
  rcReconBtn.style.display = 'none';
  // Show manual button after 8s
  setTimeout(()=>{ rcReconBtn.style.display='inline-block'; },8000);
  rcTimeout = setTimeout(giveUp, 90000);
}
function hideReconnect(){
  rcOverlay.classList.remove('show');
  if(rcTimeout){clearTimeout(rcTimeout);rcTimeout=null;}
  if(rcAutoInterval){clearInterval(rcAutoInterval);rcAutoInterval=null;}
  rcAttempts=0;
}
function giveUp(){ hideReconnect(); location.reload(); }

document.getElementById('btn-give-up').onclick = giveUp;
rcReconBtn.onclick = ()=>{
  if(isHost) reinitHost();
  else       attemptJoinReconnect();
};

/* Hook a connection object and set up all handlers */
function hookConn(c){
  conn=c;
  c.on('data',  onData);
  c.on('open',  ()=>{
    hideReconnect();
    rcAttempts=0;
  });
  c.on('close', ()=>onDrop());
  c.on('error', e=>{
    hint('Bağlantı hatası: '+e.type,'err');
    onDrop();
  });
}

function onDrop(){
  if(!document.getElementById('game').classList.contains('on')) return;
  showReconnect(isHost ? 'rakip yeniden bağlanmayı bekliyor…' : 'bağlantı kesildi, yeniden bağlanıyor…');
  hint('Bağlantı kesildi','err');
  if(isHost){
    // Host re-listens for incoming connection with same roomCode peer
    listenForReconnect();
  } else {
    // Guest auto-retries every 3s
    startGuestRetry();
  }
}

function listenForReconnect(){
  // peer is still alive with same ID (roomCode) — just re-attach connection listener
  if(!peer || peer.destroyed){
    // peer was destroyed, recreate with same ID
    peer = newPeer(roomCode);
    peer.on('error', ()=>{});
  }
  peer.off('connection'); // remove old listeners
  peer.on('connection', c=>{
    hookConn(c);
    c.on('open',()=>{
      hideReconnect();
      // Re-sync state to guest
      tx({t:'state',s:dumpState()});
      tx({t:'score',sc:SCORE});
      hint('Rakip yeniden bağlandı');
      refreshUI(); render();
    });
  });
}

function startGuestRetry(){
  if(rcAutoInterval) clearInterval(rcAutoInterval);
  rcAttempts=0;
  rcAutoInterval=setInterval(()=>{
    if(conn && conn.open){ clearInterval(rcAutoInterval); return; }
    if(rcAttempts>20){ clearInterval(rcAutoInterval); return; }
    rcAttempts++;
    attemptJoinReconnect();
  },3000);
}

function attemptJoinReconnect(){
  if(!roomCode) return;
  // Destroy old peer if needed but keep roomCode
  if(peer && !peer.destroyed){ try{ peer.destroy(); }catch(e){} }
  peer = newPeer();
  peer.on('open',()=>{
    const c=peer.connect(roomCode,CONN_OPTS);
    hookConn(c);
    c.on('open',()=>{
      hideReconnect();
      hint('Yeniden bağlandı');
      refreshUI(); render();
    });
  });
  peer.on('error',()=>{});
}

/* ════════════════════════════════════════
   NETWORK
════════════════════════════════════════ */
function connReady(){
  cmsg('Bağlandı!','ok'); jmsg('Bağlandı!','ok');
  rcAttempts=0;
  setTimeout(startGame,500);
}

function tx(obj){ if(conn&&conn.open) conn.send(obj); }

function onData(msg){
  switch(msg.t){
    case 'state':  loadState(msg.s); refreshUI(); render(); break;
    case 'end':    S.winner=msg.w; S.phase='end'; goEnd(msg.w===myColor); break;
    case 'score':  SCORE.me=msg.sc.opp; SCORE.opp=msg.sc.me; updateScoreUI(); break;
    case 'rematch':
      if(voted) doRematch();
      else{ voted=true; hint('Rakip tekrar oynamak istiyor…','hi'); }
      break;
  }
}

/* ════════════════════════════════════════
   LOBBY
════════════════════════════════════════ */
document.getElementById('btn-create').onclick=()=>{
  const code=mkCode();
  roomCode=code; isHost=true; myColor='white';
  const p=newPeer(code); peer=p;
  p.on('error',e=>{
    cmsg('Hata: '+e.type,'err');
    if(e.type==='unavailable-id') setTimeout(()=>document.getElementById('btn-create').onclick(),400);
  });
  p.on('open',id=>{
    document.getElementById('btn-create').disabled=true;
    document.getElementById('create-more').style.display='flex';
    document.getElementById('mycode').textContent=id;
    p.on('connection',c=>{ hookConn(c); c.open?connReady():c.on('open',connReady); });
  });
};

document.getElementById('btn-join').onclick=doJoin;
document.getElementById('codein').onkeydown=e=>{ if(e.key==='Enter') doJoin(); };
document.getElementById('codein').oninput=e=>{ e.target.value=e.target.value.toUpperCase().replace(/[^A-Z0-9]/g,''); };

function doJoin(){
  const code=document.getElementById('codein').value.trim().toUpperCase();
  if(!code) return;
  roomCode=code; isHost=false; myColor='black';
  jmsg('Bağlanıyor<span class="blink">…</span>');
  document.getElementById('btn-join').disabled=true;
  const p=newPeer(); peer=p;
  p.on('error',e=>{ jmsg('Hata: '+e.type,'err'); document.getElementById('btn-join').disabled=false; });
  p.on('open',()=>{
    const c=p.connect(code,CONN_OPTS); hookConn(c);
    c.on('open',connReady);
    c.on('error',e=>{ jmsg('Bağlanamadı ('+e.type+')','err'); document.getElementById('btn-join').disabled=false; });
    setTimeout(()=>{ if(!c.open){ jmsg('Zaman aşımı — kodu kontrol et','err'); document.getElementById('btn-join').disabled=false; }},10000);
  });
}

document.getElementById('btn-copy').onclick=()=>{
  navigator.clipboard.writeText(document.getElementById('mycode').textContent).catch(()=>{});
  document.getElementById('btn-copy').textContent='Kopyalandı';
  setTimeout(()=>document.getElementById('btn-copy').textContent='Kopyala',1600);
};

function cmsg(h,c){ const e=document.getElementById('cmsg'); e.innerHTML=h; e.className='msg'+(c?' '+c:''); }
function jmsg(h,c){ const e=document.getElementById('jmsg'); e.innerHTML=h; e.className='msg'+(c?' '+c:''); }
function mkCode(){ const a='ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; return Array.from({length:4},()=>a[Math.floor(Math.random()*a.length)]).join(''); }

/* ════════════════════════════════════════
   GAME FLOW
════════════════════════════════════════ */
function startGame(){
  resetState(); voted=false;
  document.getElementById('cvs-wrap').classList.toggle('flipped', myColor==='black');
  show('game'); refreshUI(); updateOffBars(); updateScoreUI();
}

function goEnd(won){
  // Update score
  if(won) SCORE.me++;
  else    SCORE.opp++;
  // Sync score to opponent
  tx({t:'score', sc:SCORE});

  setTimeout(()=>{
    show('end');
    const w=document.getElementById('endword');
    w.textContent=won?'kazandın':'kaybettin';
    w.className='bigword '+(won?'win':'lose');
    document.getElementById('endsub').textContent='sen '+(myColor==='white'?'beyaz':'siyah')+' oynadın';
    document.getElementById('score-display').textContent=`skor  ${SCORE.me} — ${SCORE.opp}`;
  },300);
}

document.getElementById('btn-rematch').onclick=()=>{
  if(voted){doRematch();return;}
  voted=true; tx({t:'rematch'});
  document.getElementById('btn-rematch').disabled=true;
  document.getElementById('btn-rematch').textContent='Bekleniyor…';
};
document.getElementById('btn-home').onclick=()=>location.reload();

function doRematch(){
  voted=false;
  myColor=myColor==='white'?'black':'white';
  document.getElementById('btn-rematch').disabled=false;
  document.getElementById('btn-rematch').textContent='Tekrar Oyna';
  document.getElementById('cvs-wrap').classList.toggle('flipped',myColor==='black');
  startGame();
}

/* ════════════════════════════════════════
   STATE SYNC
════════════════════════════════════════ */
function dumpState(){ return {board:[...S.board],bar:[...S.bar],off:[...S.off],dice:[...S.dice],used:[...S.used],turn:S.turn,phase:S.phase,winner:S.winner}; }
function loadState(s){ S.board=s.board;S.bar=s.bar;S.off=s.off;S.dice=s.dice;S.used=s.used;S.turn=s.turn;S.phase=s.phase;S.winner=s.winner;S.sel=null;S.valid=[]; }

/* ════════════════════════════════════════
   RULES
════════════════════════════════════════ */
const DIR={white:-1,black:1};
const isW  =c=>c==='white';
const flip =c=>c==='white'?'black':'white';
const bidx =c=>isW(c)?0:1;
const myBI =()=>bidx(myColor);
const myBarCount=()=>S.bar[myBI()];
const freeDice  =()=>S.dice.filter((_,i)=>!S.used[i]);

function canLand(pt,color){ const v=S.board[pt]; return isW(color)?v>=-1:v<=1; }

function allHome(color){
  if(S.bar[bidx(color)]>0) return false;
  if(isW(color)){ for(let i=6;i<24;i++) if(S.board[i]>0) return false; }
  else           { for(let i=0;i<18;i++) if(S.board[i]<0) return false; }
  return true;
}
function furthestHome(color){
  if(isW(color)){ for(let i=5;i>=0;i--)   if(S.board[i]>0) return i; }
  else           { for(let i=18;i<=23;i++) if(S.board[i]<0) return i; }
  return -1;
}
function pipDist(idx,color){ return isW(color)?idx+1:24-idx; }

function barTargets(color){
  const uniq=[...new Set(freeDice())],out=[];
  for(const d of uniq){
    const to=isW(color)?24-d:d-1;
    if(to>=0&&to<=23&&canLand(to,color)) out.push(to);
  }
  return out;
}
function pointTargets(from,color){
  const d=DIR[color],uniq=[...new Set(freeDice())],out=[],bear=allHome(color);
  for(const die of uniq){
    const to=from+d*die;
    if(to>=0&&to<=23){ if(canLand(to,color)) out.push(to); }
    else if(bear){
      const pip=pipDist(from,color);
      if(die===pip){ if(!out.includes('off')) out.push('off'); }
      else if(die>pip&&from===furthestHome(color)){ if(!out.includes('off')) out.push('off'); }
    }
  }
  return out;
}
function hasAnyMove(color){
  if(S.bar[bidx(color)]>0) return barTargets(color).length>0;
  for(let i=0;i<24;i++){
    const v=S.board[i],mine=isW(color)?v>0:v<0;
    if(mine&&pointTargets(i,color).length>0) return true;
  }
  return false;
}
function useDie(pips){
  for(let i=0;i<S.dice.length;i++){
    if(!S.used[i]&&S.dice[i]===pips){S.used[i]=true;return;}
  }
  const un=S.dice.map((v,i)=>({v,i})).filter(x=>!S.used[x.i]).sort((a,b)=>b.v-a.v);
  if(un.length) S.used[un[0].i]=true;
}
function applyMove(from,to){
  const w=isW(myColor),idx=myBI();
  if(from==='barW'||from==='barB') S.bar[idx]--;
  else S.board[from]-=w?1:-1;
  if(to==='off'){ S.off[idx]++; }
  else{
    const dest=S.board[to];
    if((w&&dest===-1)||(!w&&dest===1)){
      S.board[to]=0;
      S.bar[bidx(flip(myColor))]++;
    }
    S.board[to]+=w?1:-1;
  }
  let pips;
  if(from==='barW'||from==='barB') pips=w?24-to:to+1;
  else if(to==='off')              pips=w?from+1:24-from;
  else                             pips=Math.abs(to-from);
  useDie(pips);
  S.sel=null; S.valid=[];
  updateOffBars();
  if(S.off[idx]>=15){
    S.phase='end'; S.winner=myColor;
    tx({t:'state',s:dumpState()}); tx({t:'end',w:myColor});
    goEnd(true); return;
  }
  const more=freeDice().length>0&&hasAnyMove(myColor);
  if(more){ tx({t:'state',s:dumpState()}); refreshUI(); render(); }
  else    endTurn();
}
function endTurn(){
  S.phase='roll'; S.dice=[]; S.used=[];
  S.turn=flip(S.turn); S.sel=null; S.valid=[];
  tx({t:'state',s:dumpState()});
  refreshUI(); render();
}

/* ════════════════════════════════════════
   OFF BARS
════════════════════════════════════════ */
function updateOffBars(){
  if(!myColor) return;
  const myIdx=myBI(), oppIdx=bidx(flip(myColor)), isMeW=isW(myColor);
  renderPips('off-opp-pips','off-opp-cnt',S.off[oppIdx],!isMeW);
  renderPips('off-my-pips', 'off-my-cnt', S.off[myIdx],  isMeW);
}
function renderPips(pId,cId,count,white){
  const pe=document.getElementById(pId),ce=document.getElementById(cId);
  pe.innerHTML='';
  if(!count){ce.textContent='';return;}
  for(let i=0;i<Math.min(count,15);i++){
    const d=document.createElement('span');
    d.className='off-pip '+(white?'w':'b');
    pe.appendChild(d);
  }
  ce.textContent=String(count);
}

/* ════════════════════════════════════════
   CANVAS
════════════════════════════════════════ */
const cvs=document.getElementById('cvs');
const ctx=cvs.getContext('2d');

function resizeCvs(){
  const wrap=document.getElementById('game');
  const W=Math.min(wrap.clientWidth-20,1160);
  const H=Math.round(W*0.62);
  cvs.width=W*devicePixelRatio; cvs.height=H*devicePixelRatio;
  cvs.style.width=W+'px'; cvs.style.height=H+'px';
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize',()=>{ if(document.getElementById('game').classList.contains('on')){resizeCvs();render();} });

const CW=()=>cvs.width/devicePixelRatio;
const CH=()=>cvs.height/devicePixelRatio;

function L(){
  const W=CW(),H=CH(),mg=Math.round(W*0.014),bw=Math.round(W*0.055);
  const pw=(W-bw-mg*2)/12,ph=(H/2-mg)*0.88,bx=mg+pw*6,mid=H/2;
  const avail=H/2-mg-6,r=Math.min(pw*0.44,avail/11);
  return{W,H,mg,bw,pw,ph,bx,mid,r};
}
function colX(col,l){ return col<6?l.mg+col*l.pw:l.mg+l.bw+col*l.pw; }
function idxToCol(i){ return i>=12?i-12:11-i; }
function idxCX(i,l){ return colX(idxToCol(i),l)+l.pw/2; }
function isTop(i){ return i>=12; }
function chkY(top,k,r,l){ const g=r*0.15; return top?l.mg+r+k*(r*2+g):l.H-l.mg-r-k*(r*2+g); }

const drag={active:false,from:null,white:false,x:0,y:0};

function render(){
  if(!S.board) return;
  const l=L();
  const{W,H,mg,bw,pw,ph,bx,mid,r}=l;

  ctx.fillStyle='#0e0a06'; ctx.fillRect(0,0,W,H);
  ctx.fillStyle='#2c1f0e'; ctx.fillRect(mg,mg,W-mg*2,H-mg*2);
  ctx.fillStyle='#241809'; ctx.fillRect(mg,mid-1,W-mg*2,2);
  ctx.fillStyle='#1a1208'; ctx.fillRect(bx,mg,bw,H-mg*2);

  // Triangles — no point numbers
  for(let i=0;i<24;i++){
    const col=idxToCol(i),top=isTop(i),x=colX(col,l);
    ctx.fillStyle=col%2===0?'#8b3a1a':'#0e0a06';
    ctx.beginPath();
    if(top){ctx.moveTo(x,mg);ctx.lineTo(x+pw,mg);ctx.lineTo(x+pw/2,mg+ph);}
    else   {ctx.moveTo(x,H-mg);ctx.lineTo(x+pw,H-mg);ctx.lineTo(x+pw/2,H-mg-ph);}
    ctx.closePath(); ctx.fill();
    if(S.valid.includes(i)){
      ctx.fillStyle='rgba(80,220,80,.55)'; ctx.fill();
      ctx.strokeStyle='rgba(80,255,80,.9)'; ctx.lineWidth=2; ctx.stroke();
    }
    if(S.sel===i){
      ctx.fillStyle='rgba(255,210,60,.55)'; ctx.fill();
      ctx.strokeStyle='rgba(255,230,80,.9)'; ctx.lineWidth=2; ctx.stroke();
    }
  }

  // Checkers
  for(let i=0;i<24;i++){
    const v=S.board[i]; if(!v) continue;
    const top=isTop(i),cx=idxCX(i,l),abs=Math.abs(v);
    const n=(drag.active&&drag.from===i)?Math.min(abs,5)-1:Math.min(abs,5);
    for(let k=0;k<n;k++) drawChecker(cx,chkY(top,k,r,l),r,v>0,(abs>5&&k===4)?abs:null);
  }

  // Bar checkers
  const bcx=bx+bw/2,br=Math.min(bw*0.44,r);
  if(S.bar[0]>0){
    const cnt=(drag.active&&drag.from==='barW')?Math.min(S.bar[0],3)-1:Math.min(S.bar[0],3);
    for(let k=0;k<cnt;k++) drawChecker(bcx,mid-br*1.2-k*(br*2+br*0.15),br,true,(S.bar[0]>3&&k===2)?S.bar[0]:null);
  }
  if(S.bar[1]>0){
    const cnt=(drag.active&&drag.from==='barB')?Math.min(S.bar[1],3)-1:Math.min(S.bar[1],3);
    for(let k=0;k<cnt;k++) drawChecker(bcx,mid+br*1.2+k*(br*2+br*0.15),br,false,(S.bar[1]>3&&k===2)?S.bar[1]:null);
  }

  // Bar highlights
  const wBarSel=S.sel==='barW'||drag.from==='barW';
  const bBarSel=S.sel==='barB'||drag.from==='barB';
  const barEsc=S.valid.includes('bar-esc');
  if(wBarSel){ctx.fillStyle='rgba(255,210,60,.4)';ctx.fillRect(bx,mg,bw,mid-mg);}
  else if(barEsc&&myColor==='white'){ctx.fillStyle='rgba(80,220,80,.4)';ctx.fillRect(bx,mg,bw,mid-mg);}
  if(bBarSel){ctx.fillStyle='rgba(255,210,60,.4)';ctx.fillRect(bx,mid,bw,H/2-mg);}
  else if(barEsc&&myColor==='black'){ctx.fillStyle='rgba(80,220,80,.4)';ctx.fillRect(bx,mid,bw,H/2-mg);}

  // OFF zone
  if(S.valid.includes('off')||(drag.active&&S.valid.includes('off'))){
    ctx.fillStyle='rgba(80,220,80,.35)';
    ctx.fillRect(0,0,mg,H); ctx.fillRect(W-mg,0,mg,H);
    ctx.fillStyle='rgba(80,255,80,.9)';
    ctx.font=`bold ${Math.max(10,mg*0.6)}px DM Mono,monospace`;
    const offRot=myColor==='black'?Math.PI/2:-Math.PI/2;
    const offRotR=myColor==='black'?-Math.PI/2:Math.PI/2;
    ctx.save();ctx.translate(mg/2,H/2);ctx.rotate(offRot);ctx.fillText('OFF',0,0);ctx.restore();
    ctx.save();ctx.translate(W-mg/2,H/2);ctx.rotate(offRotR);ctx.fillText('OFF',0,0);ctx.restore();
  }

  // Borders
  ctx.strokeStyle='#5a3a1a';ctx.lineWidth=2;ctx.strokeRect(mg,mg,W-mg*2,H-mg*2);
  ctx.strokeStyle='#3a2810';ctx.lineWidth=1;ctx.strokeRect(bx,mg,bw,H-mg*2);

  if(drag.active) drawChecker(drag.x,drag.y,r*1.1,drag.white,null);
}

function drawChecker(cx,cy,r,white,label){
  ctx.beginPath();ctx.arc(cx,cy+r*0.08,r,0,Math.PI*2);
  ctx.fillStyle='rgba(0,0,0,0.4)';ctx.fill();
  ctx.beginPath();ctx.arc(cx,cy,r,0,Math.PI*2);
  ctx.fillStyle=white?'#e8dfc8':'#222222';ctx.fill();
  ctx.beginPath();ctx.arc(cx,cy,r*0.75,0,Math.PI*2);
  ctx.strokeStyle=white?'rgba(255,255,255,0.5)':'rgba(255,255,255,0.12)';
  ctx.lineWidth=1.5;ctx.stroke();
  ctx.beginPath();ctx.arc(cx,cy,r,0,Math.PI*2);
  ctx.strokeStyle=white?'#b8a888':'#444444';ctx.lineWidth=1.5;ctx.stroke();
  if(label!=null){
    ctx.save();
    if(myColor==='black'){
      ctx.translate(cx,cy); ctx.rotate(Math.PI); ctx.translate(-cx,-cy);
    }
    ctx.fillStyle=white?'#1a1208':'#e8dfc8';
    ctx.font=`bold ${Math.max(9,r*.72)}px DM Mono,monospace`;
    ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(label,cx,cy);ctx.textBaseline='alphabetic';
    ctx.restore();
  }
}

/* ════════════════════════════════════════
   INPUT — coordinates flipped for black
════════════════════════════════════════ */
function canvasXY(e){
  const rect=cvs.getBoundingClientRect();
  const touch=e.touches?e.touches[0]:e;
  let x=(touch.clientX-rect.left)*(CW()/rect.width);
  let y=(touch.clientY-rect.top)*(CH()/rect.height);
  if(myColor==='black'){x=CW()-x;y=CH()-y;}
  return[x,y];
}
function flipCoords(clientX,clientY){
  const rect=cvs.getBoundingClientRect();
  let x=(clientX-rect.left)*(CW()/rect.width);
  let y=(clientY-rect.top)*(CH()/rect.height);
  if(myColor==='black'){x=CW()-x;y=CH()-y;}
  return[x,y];
}

function hitTestFrom(mx,my,l){
  const{bx,bw,H,mid}=l;
  if(mx>=bx&&mx<=bx+bw){
    if(my<mid&&myColor==='white'&&S.bar[0]>0) return'barW';
    if(my>=mid&&myColor==='black'&&S.bar[1]>0) return'barB';
    return null;
  }
  const pt=pixelToIdx(mx,my,l);
  if(pt===null) return null;
  const v=S.board[pt],mine=isW(myColor)?v>0:v<0;
  return mine&&myBarCount()===0?pt:null;
}
function startDrag(mx,my){
  if(S.turn!==myColor||S.phase!=='move') return false;
  const l=L(),from=hitTestFrom(mx,my,l);
  if(from===null) return false;
  drag.active=true;drag.from=from;drag.x=mx;drag.y=my;drag.white=myColor==='white';
  if(from==='barW'||from==='barB'){S.sel=from;S.valid=[...barTargets(myColor),'bar-esc'];}
  else{S.sel=from;S.valid=pointTargets(from,myColor);}
  cvs.classList.add('dragging');render();return true;
}
function moveDrag(mx,my){if(!drag.active)return;drag.x=mx;drag.y=my;render();}
function endDrag(mx,my){
  if(!drag.active)return;
  drag.active=false;cvs.classList.remove('dragging');
  const l=L();const{mg,W,bx,bw}=l;
  if(S.valid.includes('off')&&(mx<mg||mx>W-mg)){applyMove(drag.from,'off');return;}
  if(mx>=bx&&mx<=bx+bw){S.sel=null;S.valid=[];render();return;}
  const pt=pixelToIdx(mx,my,l);
  if(pt!==null&&S.valid.includes(pt)) applyMove(drag.from,pt);
  else{S.sel=null;S.valid=[];render();}
}

cvs.addEventListener('mousedown',e=>{e.preventDefault();const[mx,my]=canvasXY(e);startDrag(mx,my);});
window.addEventListener('mousemove',e=>{if(!drag.active)return;const[x,y]=flipCoords(e.clientX,e.clientY);moveDrag(x,y);});
window.addEventListener('mouseup',e=>{if(!drag.active)return;const[x,y]=flipCoords(e.clientX,e.clientY);endDrag(x,y);});
cvs.addEventListener('touchstart',e=>{e.preventDefault();const[mx,my]=canvasXY(e);startDrag(mx,my);},{passive:false});
cvs.addEventListener('touchmove',e=>{e.preventDefault();const[mx,my]=canvasXY(e);moveDrag(mx,my);},{passive:false});
cvs.addEventListener('touchend',e=>{
  e.preventDefault();
  const t=e.changedTouches[0];
  const[x,y]=flipCoords(t.clientX,t.clientY);
  endDrag(x,y);
},{passive:false});
cvs.addEventListener('click',e=>{
  if(drag.active)return;
  if(S.turn!==myColor||S.phase!=='move')return;
  const[mx,my]=canvasXY(e);onClick(mx,my);
});

function onClick(mx,my){
  const l=L();const{bx,bw,H,mid,mg,W}=l;
  if(S.valid.includes('off')&&(mx<mg||mx>W-mg)){applyMove(S.sel,'off');return;}
  if(mx>=bx&&mx<=bx+bw){
    const key=my<mid?'barW':'barB';
    const myKey=myColor==='white'?'barW':'barB';
    if(key!==myKey)return;
    if(S.sel===myKey){S.sel=null;S.valid=[];}
    else if(myBarCount()>0){S.sel=myKey;S.valid=[...barTargets(myColor),'bar-esc'];}
    render();return;
  }
  const pt=pixelToIdx(mx,my,l);
  if(pt===null){if(S.valid.includes('off'))applyMove(S.sel,'off');return;}
  if(S.valid.includes(pt)){applyMove(S.sel,pt);return;}
  const v=S.board[pt],mine=isW(myColor)?v>0:v<0;
  if(myBarCount()===0&&mine){
    if(S.sel===pt){S.sel=null;S.valid=[];}
    else{S.sel=pt;S.valid=pointTargets(pt,myColor);}
  }else{S.sel=null;S.valid=[];}
  render();
}

function pixelToIdx(mx,my,l){
  const{mg,bw,pw,bx,W,H}=l;
  if(mx<mg||mx>W-mg)return null;
  const top=my<H/2;let col;
  if(mx<bx)        col=Math.floor((mx-mg)/pw);
  else if(mx>bx+bw) col=Math.floor((mx-bx-bw)/pw)+6;
  else return null;
  if(col<0||col>11)return null;
  const idx=top?col+12:11-col;
  return idx>=0&&idx<=23?idx:null;
}

/* ════════════════════════════════════════
   UI
════════════════════════════════════════ */
const pillEl =document.getElementById('pill');
const diceEl =document.getElementById('dice');
const rollBtn=document.getElementById('btn-roll');

function refreshUI(){
  const mt=S.turn===myColor;
  pillEl.textContent=mt?'senin sıran':'rakip oynuyor';
  pillEl.className='pill '+(mt?'mine':'theirs');
  diceEl.innerHTML='';
  S.dice.forEach((d,i)=>{
    const el=document.createElement('div');
    el.className='die '+(S.used[i]?'dead':'live');
    el.textContent=d;diceEl.appendChild(el);
  });
  rollBtn.disabled=!(mt&&S.phase==='roll');
  hint(mt?(S.phase==='roll'?'zar at':myBarCount()>0?"bar'dan çık":'taş seç veya sürükle'):'rakip oynuyor…');
  updateOffBars();
  updateScoreUI();
}

function hint(text,cls){
  const el=document.getElementById('hint');
  el.textContent=text;el.className='hint'+(cls?' '+cls:'');
}

/* ════════════════════════════════════════
   DICE
════════════════════════════════════════ */
rollBtn.onclick=()=>{
  if(S.turn!==myColor||S.phase!=='roll')return;
  rollBtn.disabled=true;
  const ANIM=600,STEP=80;let elapsed=0;
  diceEl.innerHTML='';
  const tmp=[1,2].map(()=>{
    const el=document.createElement('div');
    el.className='die rolling';el.textContent=d6();diceEl.appendChild(el);return el;
  });
  const iv=setInterval(()=>{
    elapsed+=STEP;tmp.forEach(el=>el.textContent=d6());
    if(elapsed>=ANIM){
      clearInterval(iv);tmp.forEach(el=>el.classList.remove('rolling'));
      const a=d6(),b=d6();
      S.dice=a===b?[a,a,a,a]:[a,b];
      S.used=S.dice.map(()=>false);
      S.phase='move';
      diceEl.innerHTML='';
      S.dice.forEach((d,i)=>{
        const el=document.createElement('div');
        el.className='die live';el.textContent=d;diceEl.appendChild(el);
      });
      if(!hasAnyMove(myColor)){
        hint('hamle yok — pas geçiliyor…','hi');
        tx({t:'state',s:dumpState()});
        setTimeout(()=>endTurn(),1100);
      }else{
        tx({t:'state',s:dumpState()});
        refreshUI();render();
      }
    }
  },STEP);
};

function d6(){return Math.floor(Math.random()*6)+1;}
</script>
</body>
</html>